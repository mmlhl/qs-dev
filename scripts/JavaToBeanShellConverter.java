import com.github.javaparser.JavaParser;
import com.github.javaparser.ParseResult;
import com.github.javaparser.ParserConfiguration;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.body.Parameter;
import com.github.javaparser.ast.type.Type;
import com.github.javaparser.ast.type.ClassOrInterfaceType;
import com.github.javaparser.ast.stmt.Statement;
import com.github.javaparser.printer.PrettyPrinter;
import com.github.javaparser.printer.configuration.PrettyPrinterConfiguration;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Enhanced Java to BeanShell converter.
 * Features:
 * - Converts @BeanShellType annotated types to Object
 * - Extracts methods from @ScriptMethods annotated classes to root level
 * - Removes annotations (BeanShell doesn't support them)
 * - Outputs to dist/main.java
 */
public class JavaToBeanShellConverter {

    private static final Set<String> BEANSHELL_TYPES = new HashSet<>();

    static {
        // Types that should be converted to Object
        BEANSHELL_TYPES.add("MessageData");
        BEANSHELL_TYPES.add("GroupInfo");
        BEANSHELL_TYPES.add("GroupMemberInfo");
        BEANSHELL_TYPES.add("ForbiddenInfo");
        BEANSHELL_TYPES.add("FriendInfo");
    }

    public static void main(String[] args) throws IOException {
        if (args.length < 1) {
            System.err.println("Usage: java JavaToBeanShellConverter <input-java-file>");
            System.exit(1);
        }

        String inputFilePath = args[0];
        Path inputPath = Paths.get(inputFilePath);
        
        // Create dist directory
        Path projectRoot = inputPath.getParent();
        while (projectRoot != null && !Files.exists(projectRoot.resolve("build.gradle"))) {
            projectRoot = projectRoot.getParent();
        }
        if (projectRoot == null) {
            projectRoot = Paths.get(".");
        }
        
        Path distDir = projectRoot.resolve("dist");
        Files.createDirectories(distDir);
        String outputFilePath = distDir.resolve("main.java").toString();
        
        FileInputStream in = new FileInputStream(inputFilePath);
        
        // Parse the Java file
        ParserConfiguration parserConfig = new ParserConfiguration();
        ParseResult<CompilationUnit> parseResult = new JavaParser(parserConfig).parse(in);
        if (!parseResult.isSuccessful()) {
            System.err.println("Failed to parse the Java file.");
            parseResult.getProblems().forEach(System.err::println);
            System.exit(1);
        }
        
        CompilationUnit cu = parseResult.getResult().get();

        // Configure printer
        PrettyPrinterConfiguration printerConfig = new PrettyPrinterConfiguration();
        printerConfig.setIndentSize(4);
        PrettyPrinter printer = new PrettyPrinter(printerConfig);

        StringBuilder beanShellCode = new StringBuilder();
        beanShellCode.append("// Generated BeanShell Script\n");
        beanShellCode.append("// DO NOT EDIT THIS FILE DIRECTLY - Edit the source Java file instead\n\n");

        // Process all classes annotated with @ScriptMethods
        cu.findAll(ClassOrInterfaceDeclaration.class).forEach(classDecl -> {
            boolean hasScriptMethodsAnnotation = classDecl.getAnnotations().stream()
                    .anyMatch(anno -> anno.getNameAsString().equals("ScriptMethods"));

            if (hasScriptMethodsAnnotation) {
                // Extract all methods from this class
                classDecl.getMethods().forEach(method -> {
                    // Check if this method has @RootCode annotation
                    boolean hasRootCode = method.getAnnotations().stream()
                            .anyMatch(anno -> anno.getNameAsString().equals("RootCode"));
                    
                    if (hasRootCode) {
                        // Extract only the method body statements
                        if (method.getBody().isPresent()) {
                            method.getBody().get().getStatements().forEach(stmt -> {
                                beanShellCode.append(printer.print(stmt)).append("\n");
                            });
                            beanShellCode.append("\n");
                        }
                    } else {
                        // Extract the full method
                        String methodCode = convertMethod(method, printer);
                        beanShellCode.append(methodCode).append("\n\n");
                    }
                });
            }
        });

        // Write the result to dist/main.java
        try (FileWriter writer = new FileWriter(outputFilePath)) {
            writer.write(beanShellCode.toString());
        }
        
        System.out.println("Conversion successful!");
        System.out.println("Output written to: " + outputFilePath);
    }

    /**
     * Convert a method declaration to BeanShell format:
     * - Replace @BeanShellType types with Object
     * - Remove all annotations
     * - Keep method signature and body
     */
    private static String convertMethod(MethodDeclaration method, PrettyPrinter printer) {
        // Clone the method to avoid modifying the original AST
        MethodDeclaration converted = method.clone();

        // Remove all annotations
        converted.getAnnotations().clear();

        // Convert return type if needed
        Type returnType = converted.getType();
        convertTypeToObject(returnType);

        // Convert parameter types if needed
        for (Parameter param : converted.getParameters()) {
            convertTypeToObject(param.getType());
        }

        return printer.print(converted);
    }

    /**
     * Convert a Type to Object if it's a BeanShell type
     */
    private static void convertTypeToObject(Type type) {
        if (type.isClassOrInterfaceType()) {
            ClassOrInterfaceType classType = type.asClassOrInterfaceType();
            String typeName = classType.getNameAsString();
            
            // Check if this is a BeanShell type
            if (BEANSHELL_TYPES.contains(typeName)) {
                classType.setName("Object");
                classType.setTypeArguments((com.github.javaparser.ast.NodeList) null);
            }
            
            // Handle generic type arguments (e.g., ArrayList<MessageData>)
            if (classType.getTypeArguments().isPresent()) {
                classType.getTypeArguments().get().forEach(typeArg -> {
                    if (typeArg.isClassOrInterfaceType()) {
                        ClassOrInterfaceType argType = typeArg.asClassOrInterfaceType();
                        if (BEANSHELL_TYPES.contains(argType.getNameAsString())) {
                            argType.setName("Object");
                            argType.setTypeArguments((com.github.javaparser.ast.NodeList) null);
                        }
                    }
                });
            }
        }
    }
}