# QStory BeanShell 脚本开发项目概览

## 项目目的
为 QStory BeanShell 脚本开发提供完整的 IDE 代码提示支持。解决在 IDEA 中编写 BeanShell 脚本时缺少类型提示的问题。

## 核心原理
1. **开发阶段**: 在 Java 环境中编写代码，使用具体类型（如 `MessageData`）享受完整的 IDE 提示
2. **转换阶段**: 通过 JavaParser 将 Java 代码转换为 BeanShell 格式，自动替换类型为 `Object`
3. **模块化支持**: 支持 `load()` 加载子模块，实现代码模块化组织
4. **运行阶段**: 生成的 `dist/main.java` 及模块文件可直接在 QStory 中使用

## 关键组件

### 1. 类型定义 (`src/main/java/me/mm/qs/script/types/`)
- `MessageData.java` - 消息数据结构（含所有字段：MessageContent, UserUin, GroupUin, IsGroup 等）
- `GroupInfo.java` - 群组信息（GroupUin, GroupName, AdminList 等）
- `GroupMemberInfo.java` - 群成员信息
- `ForbiddenInfo.java` - 禁言信息
- `FriendInfo.java` - 好友信息

所有类型标记 `@BeanShellType`，转换时自动变为 `Object`。

### 2. 注解系统 (`src/main/java/me/mm/qs/script/annotation/`)
- `@BeanShellType` - 标记类型，转换时替换为 Object
- `@ScriptMethods` - 标记类，其方法会被提取到 BeanShell 根级别
- `@RootCode` - 标记方法，仅提取方法体到根级别（用于初始化代码）
- `@ScriptInfo` - 定义脚本元数据（name, author, version, description, tags, id）

### 3. 基类 (`QScriptBase.java`)
定义所有 QStory 全局变量和 API 方法：
- 全局变量：`myUin`, `context`, `appPath`, `loader`, `pluginID`
- 回调方法：`onMsg()`, `onCreateMenu()`, `onForbiddenEvent()` 等
- API 方法：`sendMsg()`, `toast()`, `getGroupList()` 等
- 现已使用具体类型（如 `MessageData`）而非 `Object`

### 4. 转换器 (`scripts/JavaToBeanShellConverter.java`)
使用 JavaParser 实现以下转换：
- 识别 `@ScriptMethods` 注解的类
- 提取其中的方法到根级别
- 替换所有 `@BeanShellType` 类型为 `Object`
- 处理泛型（`ArrayList<MessageData>` → `ArrayList<Object>`）
- 移除所有注解
- 对 `@RootCode` 方法仅提取方法体
- **递归转换子目录**中的所有 Java 文件
- **自动生成脚本元数据文件**（desc.txt 和 info.prop）
- 输出到 `dist/` 目录，保持相同的目录结构

## 工作流程

1. **编写脚本** - 在 `myscript/` 包中编写：
```java
// Main.java - 主入口
package me.mm.qs.myscript;

@ScriptInfo(
    name = "示例脚本",
    author = "Your Name",
    version = "1.0",
    description = "脚本描述",
    tags = "群聊辅助,娱乐功能"
)
@ScriptMethods
public class Main extends QScriptBase {
    @Override
    public void onMsg(MessageData msg) {
        // 完整的 IDE 提示
        String text = msg.MessageContent;
    }
}

@ScriptMethods
class Init extends QScriptBase {
    @RootCode
    public void init() {
        // 加载模块
        load("utils/Helper.java");
        addItem("菜单", "callback");
    }
}
```

```java
// utils/Helper.java - 工具模块
package me.mm.qs.myscript.utils;

@ScriptMethods
public class Helper extends QScriptBase {
    public String formatQQ(String qq) {
        return "[QQ:" + qq + "]";
    }
}
```

2. **编译转换** - 运行 `gradlew.bat compileJava`：
   - 编译 Java 代码
   - 自动运行 `JavaToBeanShellConverter`
   - 递归转换 `myscript/` 包及子包
   - 生成 `dist/main.java` 和 `dist/utils/Helper.java`
   - **自动生成 `desc.txt` 和 `info.prop`**
   - **首次运行生成脚本ID并保存到 `.script-id`，后续保持不变**

3. **使用脚本** - 将 `dist/` 目录内容复制到 QStory 脚本目录

## 转换示例

**输入 (Main.java)**:
```java
@Override
public void onMsg(MessageData msg) {
    toast(msg.MessageContent);
}

@RootCode
public void init() {
    load("utils/Helper.java");
}
```

**输出 (dist/main.java)**:
```java
public void onMsg(Object msg) {
    toast(msg.MessageContent);
}

load("utils/Helper.java");
```

## 模块化结构

**目录组织**:
```
myscript/
├── Main.java          # 主入口，转换为 main.java
└── utils/             # 工具模块目录
    ├── Helper.java    # 工具类，转换为 utils/Helper.java
    └── MessageHandler.java  # 消息处理，转换为 utils/MessageHandler.java
```

**使用 load() 加载模块**:
```java
@RootCode
public void init() {
    // 加载工具模块（相对于脚本目录）
    load("utils/MessageHandler.java");
    load("utils/Helper.java");
    
    // 现在可以使用模块中的方法
    // formatQQ(), parseTimeBymessage() 等
}
```

## Gradle 配置
- `compileJava.finalizedBy convertScript` - 编译后自动转换
- `convertScript` 任务调用 `JavaToBeanShellConverter` 递归处理 `myscript/` 包

## 关键设计决策

1. **类型映射**: 通过 `BEANSHELL_TYPES` Set 维护需转换的类型列表
2. **方法提取**: 使用 JavaParser AST 遍历类和方法
3. **注解检测**: 通过注解名称判断处理方式
4. **模块化**: 递归转换子目录，保持目录结构
5. **load() 实现**: 在 `@RootCode` 中使用 `load()` 加载模块文件
6. **元数据生成**: 从 `@ScriptInfo` 提取信息生成 desc.txt 和 info.prop
7. **ID持久化**: 脚本ID存储在 `.script-id` 中，确保唯一性和稳定性
8. **输出目录**: 输出到 `dist/` 并保持相对路径结构

## API 来源
所有 API 定义基于 `src/api.md` 中的 QStory 官方文档。

## 技术栈
- Java 17+
- Gradle
- JavaParser 3.25.0
- Android SDK (android.jar 用于 Context 等类型)

## 注意事项
1. 不要直接编辑 `dist/` 目录下的文件，它们会被自动覆盖
2. 所有开发在 `myscript/` 包中进行
3. 新增类型需同时更新 `JavaToBeanShellConverter.BEANSHELL_TYPES`
4. `load()` 路径相对于脚本目录（即 `dist/`）
5. 模块文件也需要用 `@ScriptMethods` 标记
6. 脚本元数据通过 `@ScriptInfo` 在 Main.java 中配置
7. `.script-id` 文件不要加入版本控制，每个开发者应有独立的ID

## 错误分析工作流

**拉取错误文件分析**:
```bash
gradlew fetchError
```
此任务会:
1. 从设备拉取 `/storage/emulated/0/Android/data/com.tencent.mobileqq/QStory/Plugin/脚本名称/error.txt`
2. 保存到项目根目录的 `error.txt` 文件
3. 自动显示错误内容到控制台
4. 用于分析脚本运行时错误

**部署时自动清空错误**:
- 每次 `gradlew deployScript` 时自动推送空的 `error.txt`
- 确保每次测试都能看到新的错误信息
- 避免混淆历史错误和新错误

**分析流程**:
1. 部署脚本到设备
2. 在 QQ 中运行测试
3. 运行 `gradlew fetchError` 查看错误
4. 修复问题后重新部署
